import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-Ds4AiUcn.js";const e={},p=t(`<h2 id="类组件" tabindex="-1"><a class="header-anchor" href="#类组件"><span>类组件</span></a></h2><p>在 React 中，类组件就是基于ES6语法，通过继承<code>React.Component</code>得到的组件 。</p><details class="hint-container details"><summary>类组件示例代码</summary><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始化类组件的 state</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token string">&quot;111&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 编写生命周期方法 didMount</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略业务逻辑</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 编写自定义的实例方法</span>
  <span class="token function-variable function">changeText</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newText</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 更新 state</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">text</span><span class="token operator">:</span> newText
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 编写生命周期方法 render</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;demoClass&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>text<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">changeText</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>点我修改<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="函数组件" tabindex="-1"><a class="header-anchor" href="#函数组件"><span>函数组件</span></a></h2><p>在函数组件也称为<strong>无状态组件</strong>，顾名思义就是以函数形式存在的React组件。</p><blockquote><p>在hooks出现之前，react 中的函数组件通常只考虑负责UI的渲染，没有自身的状态，没有业务逻辑代码，是一个纯函数。</p></blockquote><p>下面这个函数组件就是一个纯函数，它的输出只由参数props决定，不受其它任何因素影响。</p><details class="hint-container details"><summary>函数组件示例代码</summary><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">DemoFunction</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> text <span class="token punctuation">}</span> <span class="token operator">=</span> props
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;demoFunction&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">function 组件所接收到的来自外界的文本内容是：[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>text<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>但是这种函数组件一旦我们需要给组件加状态，那就只能将组件重写为类组件，因为<strong>函数组件没有实例，没有生命周期</strong>。所以我们说在hook之前的函数组件和类组件最大的区别就是<strong>状态的有无</strong>。</p><h2 id="hook" tabindex="-1"><a class="header-anchor" href="#hook"><span>Hook</span></a></h2><p>React Hooks 是从 React 16.8 版本推出的新特性，目的是解决React的状态共享组件以及组件生命周期管理混乱的问题。React Hooks的出现标志着，React不会再存在无状态组件的情况，React将只有类组件和函数组件的概念。</p><p><code>Hooks</code>为函数组件提供了状态，也支持在函数组件中进行数据获取、订阅事件、解绑事件等。</p><h3 id="usestate" tabindex="-1"><a class="header-anchor" href="#usestate"><span>useState</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 useState 为组件提供状态。useState的参数是state的初始值，他只有组件第一次渲染的时候会生效，他的返回值是一个数组，第一个是 state，第二个是设置state的函数。</p><h3 id="useref" tabindex="-1"><a class="header-anchor" href="#useref"><span>useRef</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>用于在函数组件之间保存可变的引用。类似于组件中的 ref。改变 ref 不会触发重新渲染。</li><li>使用ref操作DOM</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> inputRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>MyInput ref<span class="token operator">=</span><span class="token punctuation">{</span>inputRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token comment">// 无法获取自定义组件的 ref </span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        聚焦输入框
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>无法获取自定义组件的ref 默认情况下，自定义组件不会暴露它们内部的DOM节点的ref。<br> 像这样将自定义子组件包装在<code>forwardRef</code>里，父组件就可以得到它的ref。<br> 假设你不想暴露出整个 <input> DOM 节点，可以采用useImperativeHandle向父组件暴露一个自定义的 ref。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> forwardRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> MyInput <span class="token operator">=</span> <span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> value<span class="token punctuation">,</span> onChange <span class="token punctuation">}</span><span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
 <span class="token function">useImperativeHandle</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// 只暴露 focus、scrollIntoView，没有别的</span>
	    <span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	      realInputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token punctuation">}</span><span class="token punctuation">,</span>
	    <span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          inputRef<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">scrollIntoView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>input
      value<span class="token operator">=</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span>
      onChange<span class="token operator">=</span><span class="token punctuation">{</span>onChange<span class="token punctuation">}</span>
      ref<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span>
    <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> MyInput<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="useeffect" tabindex="-1"><a class="header-anchor" href="#useeffect"><span>useEffect</span></a></h3><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//1. 不设置依赖项数组，那么在组件挂载时和每次渲染时，都会执行一次副作用</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;useEffect副作用执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//用setTimeout模拟ajax请求</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setList</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//2. 设置依赖项为空数组，那么只有在组件挂载和卸载时执行副作用</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;useEffect副作用执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setList</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
		<span class="token comment">// 组件卸载前的操作</span>
	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 空的依赖数组确保只在组件挂载和卸载时执行一次</span>
<span class="token comment">//3. 如果设置依赖项且不为空，那么在组件挂载时和数组中的依赖项发生变化时，副作用就会重新执行。</span>
 <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;useEffect副作用执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setList</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
		<span class="token comment">//在下一次 useEffect 执行前执行</span>
	<span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>list<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>useEffect用于处理组件的副作用：</p><ul><li>第一个参数是一个回调函数，在里面进行业务逻辑代码的书写（副作用操作） <ul><li>通常在副作用中进行ajax请求，事件的绑定与解绑，设置定时器与清除等等。</li></ul></li><li>第二个参数是依赖项数组，指定副作用的触发条件。 <ul><li>如果不设置第二个参数，那么当该组件挂载和组件每渲染一次，副作用就会执行一次</li><li>如果数组中的依赖项设置为空，那么只会在组件挂载和卸载时执行一次副作用。在useEffect的回调函数中，可以执行组件挂载时的操作，并在return返回的清理函数中执行组件卸载前的操作（例如：清除定时器、取消订阅等）</li><li>如果数组中存在依赖项，当组件挂载时和依赖项数组中的依赖发生变化，那么该副作用就会重新执行，在useEffect的回调函数中，return返回的清理函数在下一次useEffect执行前执行。</li></ul></li></ul><h3 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span>useCallback</span></a></h3><p>  用于缓存函数，以避免无效的函数重新创建。第一个参数为要缓存的函数，第二个参数为依赖项数组，如果依赖发生了变化，那么就会生成一个新的函数，否则当组件重新渲染时，不会重新定义这个函数，而是会取缓存。</p><h3 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo"><span>useMemo</span></a></h3><p>  用于缓存计算结果，以避免无效的计算重复执行。 第一个参数为要缓存的函数（注意实际被缓存的是函数被执行过后的值），第二个参数为依赖项数组，如果依赖发生了变化，那么就会重新执行这个函数，得到新的返回值；否则当组件重新渲染时，不会重新执行这个函数，而是直接取被缓存的该函数的返回值。</p><p><code>useCallback</code>、<code>useMemo</code>都是在函数式组件中用作优化性能的。</p><p>默认情况下，当一个组件重新渲染时，React将递归渲染它的所有子组件。组件中的函数就会被重新创建。因为它在JavaScript中，普通函数或箭头函数总是会生成不同的函数。</p><p><code>useCallback</code></p><ul><li>避免在内部编写额外的嵌套函数</li><li>避免组件的重新渲染</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>  比如说在父组件中接收的props有{ A,B,C }，函数handleSubmit()依赖于A和B，将这个函数作为子组件的props），如果C发生变化，会导致重新创建一个函数handleSumit()，也就导致子组件的props是不同，从而引起子组件重新渲染，但其实这是不必要，这时就可以采用useCallback，将函数handleSubmit传递给useCallback，并设置依赖项（[A，B]），保证只有依赖项（A,B)发生变化时，才会重新生成handleSubmit函数，子组件才会重新渲染，从而避免了组件内部重新创建函数，避免引起不必要的渲染。</p></div><p><code>useMemo</code></p><ul><li>避免无效的重新计算</li><li>跳过组件的重新渲染</li></ul><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>  同理，比如说父组件中接收的props有{A,B,C}，有一个对象count是依赖于A和B计算得出的，并将这个对象count作为子组件的props，正常情况当C发生变化，会导致重新创建对象count，导致传递给子组件的props不同，从而引起子组件的重新渲染，但这是不必要的重复渲染，这时就可以采用useMemo，将定义对象count的计算函数用useMemo包裹，并设置依赖项[A,B]，这样就可以保证只有在依赖项发生变化时，才会重新执行计算函数生成新的count对象，子组件才会重新渲染，从而避免了组件内部重新进行无效计算，避免引起不必要的渲染。</p></div><h3 id="usecontext" tabindex="-1"><a class="header-anchor" href="#usecontext"><span>useContext</span></a></h3><p>用于<strong>跨组件通信</strong>，以便共享数据和功能。它接收一个上下文对象（通过 React.createContext 创建）并返回当前上下文的值。这样，函数组件就可以消费上下文中的数据，而不必通过一层层的属性传递。</p><details class="hint-container details"><summary>代码示例</summary><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createContext<span class="token punctuation">,</span> useContext <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ThemeContext <span class="token operator">=</span> <span class="token function">createContext</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">MyApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>ThemeContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token string">&quot;dark&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Form <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>ThemeContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Form</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Panel title<span class="token operator">=</span><span class="token string">&quot;Welcome&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Button<span class="token operator">&gt;</span>Sign up<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Button<span class="token operator">&gt;</span>Log <span class="token keyword">in</span><span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Panel<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Panel</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> title<span class="token punctuation">,</span> children <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> className <span class="token operator">=</span> <span class="token string">&#39;panel-&#39;</span> <span class="token operator">+</span> theme<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>section className<span class="token operator">=</span><span class="token punctuation">{</span>className<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>children<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>section<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Button</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> children <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ThemeContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> className <span class="token operator">=</span> <span class="token string">&#39;button-&#39;</span> <span class="token operator">+</span> theme<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>button className<span class="token operator">=</span><span class="token punctuation">{</span>className<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>children<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>useContext() 总是在调用它的组件 上面 寻找最近的 provider。它向上搜索， 不考虑 调用 useContext() 的组件中的 provider。</p></div><h3 id="函数组件与类组件的区别" tabindex="-1"><a class="header-anchor" href="#函数组件与类组件的区别"><span>函数组件与类组件的区别</span></a></h3><p><strong>表面差异：</strong></p><ol><li>类组件有生命周期，函数组件没有</li><li>类组件需要继承class，函数组件不需要</li><li>类组件可以获取实例化的this，并且基于this做各种操作，函数组件不行。</li><li>类组件内部可以定义并维护state，函数组件为无状态组件（可以通过hooks实现）</li></ol><p>函数组件相比类组件，优点是更轻量与灵活，便于逻辑的拆分与复用。</p><p><strong>最大不同：</strong><br> 类组件捕获最新的值，函数式组件捕获了渲染时所使用的值，这是两类组件最大的不同。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>  在React中，函数组件 每次渲染组件中的变量和事件处理函数就会重新被创建。每次渲染React都会提供给这次渲染的state快照，也就是说state 的值始终“固定”在一次渲染的各个事件处理函数内部。所以，过去创建的事件处理函数拥有的是创建它们的那次渲染中的 state 值。</p><p>  而在类组件中，事件处理函数是通过this获取最新的state值。</p></div><p>在函数组件中，一个state变量的值永远不会在一次渲染的内部发生变化，即使其事件处理函数的代码是异步的。React会为每次特定的那一次渲染提供一个state快照。组件会将其jsx中返回一张包含一整套新的props和事件处理函数的UI快照， 其中所有的值都是根据那一次渲染中的state的值被计算出来的。</p><p>原因：</p><ul><li>类组件：可以直接获取组件最新的值<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>原因：类组件捕获最新的值（永远保持一致），当实例的state或props属性发生修改时，类组件直接使用this（组件的实例），所以可以直接获取组件最新的值。</p></div></li><li>函数组件：函数式组件捕获了渲染时所用的值<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>原因：函数式组件捕获了渲染所使用的值。在函数组件中，之前的state或props值，已经因为javaScript闭包的特性，保存在内存之中，无法从外部进行修改(维护多个人的状态)。 所以在定时器执行callback时，打印的还是旧值。</p></div></li></ul>`,50),o=[p];function c(l,i){return s(),a("div",null,o)}const k=n(e,[["render",c],["__file","react.html.vue"]]),d=JSON.parse(`{"path":"/interview/react.html","title":"React","lang":"zh-CN","frontmatter":{"title":"React","date":"2024-04-28T00:00:00.000Z","description":"类组件 在 React 中，类组件就是基于ES6语法，通过继承React.Component得到的组件 。 类组件示例代码 函数组件 在函数组件也称为无状态组件，顾名思义就是以函数形式存在的React组件。 在hooks出现之前，react 中的函数组件通常只考虑负责UI的渲染，没有自身的状态，没有业务逻辑代码，是一个纯函数。 下面这个函数组件就是一个...","head":[["meta",{"property":"og:url","content":"https://github.com/xinyang424/interview/react.html"}],["meta",{"property":"og:site_name","content":"XinYang"}],["meta",{"property":"og:title","content":"React"}],["meta",{"property":"og:description","content":"类组件 在 React 中，类组件就是基于ES6语法，通过继承React.Component得到的组件 。 类组件示例代码 函数组件 在函数组件也称为无状态组件，顾名思义就是以函数形式存在的React组件。 在hooks出现之前，react 中的函数组件通常只考虑负责UI的渲染，没有自身的状态，没有业务逻辑代码，是一个纯函数。 下面这个函数组件就是一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"XinYang's Blog"}],["meta",{"property":"article:published_time","content":"2024-04-28T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-04-28T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XinYang's Blog\\",\\"url\\":\\"https://xinyang424.com\\"}]}"]]},"headers":[{"level":2,"title":"类组件","slug":"类组件","link":"#类组件","children":[]},{"level":2,"title":"函数组件","slug":"函数组件","link":"#函数组件","children":[]},{"level":2,"title":"Hook","slug":"hook","link":"#hook","children":[{"level":3,"title":"useState","slug":"usestate","link":"#usestate","children":[]},{"level":3,"title":"useRef","slug":"useref","link":"#useref","children":[]},{"level":3,"title":"useEffect","slug":"useeffect","link":"#useeffect","children":[]},{"level":3,"title":"useCallback","slug":"usecallback","link":"#usecallback","children":[]},{"level":3,"title":"useMemo","slug":"usememo","link":"#usememo","children":[]},{"level":3,"title":"useContext","slug":"usecontext","link":"#usecontext","children":[]},{"level":3,"title":"函数组件与类组件的区别","slug":"函数组件与类组件的区别","link":"#函数组件与类组件的区别","children":[]}]}],"git":{"contributors":[{"name":"coder-new","email":"2578417052@qq.com","commits":1}]},"readingTime":{"minutes":9.21,"words":2764},"filePathRelative":"interview/react.md","localizedDate":"2024年4月28日","autoDesc":true}`);export{k as comp,d as data};
